---
title: "ì•Œê³ ë¦¬ì¦˜ - ì •ë ¬"
excerpt: "2023-09-25 Algorithm - order"

# layout: post
categories:
  - Python algorithm interview
tags:
  - python
  - algorithm
  - order
  - Leet code
spotifyplaylist: spotify/playlist/2KaQr0nx66AX399ZLLuTVf?si=43a48325c8fc4b16
---
í•´ë‹¹ ë‚´ìš©ì€ '[íŒŒì´ì¬ ì•Œê³ ë¦¬ì¦˜ ì¸í„°ë·°](https://product.kyobobook.co.kr/detail/S000001932748)' ì±…ì˜ ì¼ë¶€ë¥¼ ë°œì·Œí•˜ì—¬ ì •ë¦¬í•œ ë‚´ìš©ì…ë‹ˆë‹¤.

# ì•Œê³ ë¦¬ì¦˜

ì•Œê³ ë¦¬ì¦˜ íŒŒíŠ¸ì—ì„œëŠ” ì•Œê³ ë¦¬ì¦˜ì˜ ê½ƒì´ë¼ í•  ìˆ˜ ìˆëŠ” ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì„ ì‹œì‘ìœ¼ë¡œ, í° ìˆ˜ë„ ì‰½ê²Œ ì°¾ì•„ë‚´ëŠ” ì´ì§„ ê²€ìƒ‰, ì»´í“¨í„°ì˜ ê¸°ë³¸ ê°œë…ì´ì ê·¼ê°„ì„ ì´ë£¨ê³  ìˆëŠ” ë¹„íŠ¸ ë‹¨ìœ„ ì¡°ì‘ ë°©ë²•ì— ëŒ€í•˜ì—¬ í¬ìŠ¤íŒ…í•  ì˜ˆì •ì´ë‹¤.

## ì •ë ¬

> ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì€ ëª©ë¡ì˜ ìš”ì†Œë¥¼ íŠ¹ì • ìˆœì„œëŒ€ë¡œ ë„£ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ë‹¤. ëŒ€ê°œ ìˆ«ìì‹ ìˆœì„œ(Numerical Order)ì™€ ì‚¬ì „ì‹ ìˆœì„œ(Lexicographical Order)ë¡œ ì •ë ¬í•œë‹¤.
> 

### [ë¦¬ìŠ¤íŠ¸ ì •ë ¬](https://leetcode.com/problems/sort-list/)

ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¥¼ O(nlogn)ì— ì •ë ¬í•˜ë¼.

```
Input: head = [4,2,1,3]
Output: [1,2,3,4]
```

- í’€ì´: ë³‘í•© ì •ë ¬

```python
class Solution:
    # ë‘ ì •ë ¬ ë¦¬ìŠ¤íŠ¸ ë³‘í•©
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        if l1 and l2:
            if l1.val > l2.val:
                l1, l2 = l2, l1
            l1.next = self.mergeTwoLists(l1.next, l2)

        return l1 or l2

    def sortList(self, head: ListNode) -> ListNode:
        if not (head and head.next):
            return head

        # ëŸ°ë„ˆ ê¸°ë²• í™œìš©
        half, slow, fast = None, head, head
        while fast and fast.next:
            half, slow, fast = slow, slow.next, fast.next.next
        half.next = None

        # ë¶„í•  ì¬ê·€ í˜¸ì¶œ
        l1 = self.sortList(head)
        l2 = self.sortList(slow)

        return self.mergeTwoLists(l1, l2)
```

- í’€ì´: ë‚´ì¥ í•¨ìˆ˜ ì´ìš©

```python
class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        # ì—°ê²° ë¦¬ìŠ¤íŠ¸ -> íŒŒì´ì¬ ë¦¬ìŠ¤íŠ¸
        p = head
        lst: List = []
        while p:
            lst.append(p.val)
            p = p.next

        # ì •ë ¬
        lst.sort()

        # íŒŒì´ì¬ ë¦¬ìŠ¤íŠ¸ -> ì—°ê²° ë¦¬ìŠ¤íŠ¸
        p = head
        for i in range(len(lst)):
            p.val = lst[i]
            p = p.next
        return head
```

### [êµ¬ê°„ ë³‘í•©](https://leetcode.com/problems/merge-intervals/description/)

ê²¹ì¹˜ëŠ” êµ¬ê°„ì„ ë³‘í•©í•˜ë¼.

```
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].
```

- í’€ì´: ì •ë ¬í•˜ì—¬ ë³‘í•©

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        # returnê°’ì„ ë„˜ê²¨ì¤„ list ìƒì„±
        merged = []

        # intervalsì˜ 0ë²ˆì§¸ ê°’ì„ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•˜ì—¬ forë¬¸
        for i in sorted(intervals, key= lambda x: x[0]):
            # merged ì† ë§ˆì§€ë§‰ê°’ì˜ ìµœëŒ€ê°’ì´ iì˜ ìµœì†Œê°’ë³´ë‹¤ í´ ê²½ìš°
            if merged and i[0] <= merged[-1][1]:
                # maxë¥¼ í†µí•´ì„œ ìµœëŒ€ê°’ì„ ë°”ê¿”ì¤Œ
                merged[-1][1] = max(merged[-1][1], i[1])
            else:
                # += i, : ì½¤ë§ˆì—°ì‚°ì. ì¤‘ì²©ë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ì–´ì£¼ëŠ” ì—­í• 
                merged += i,

        return merged
```

### [ì‚½ì… ì •ë ¬ ë¦¬ìŠ¤íŠ¸](https://leetcode.com/problems/insertion-sort-list/)

ì—°ê²°ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚½ì… ì •ë ¬ë¡œ ì •ë ¬í•˜ë¼.

```
Input: head = [4,2,1,3]
Output: [1,2,3,4]
```

- í’€ì´: ì‚½ì… ì •ë ¬

```python
class Solution:
    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        cur = parent = ListNode(0)
        while head:
            while cur.next and cur.next.val < head.val:
                cur = cur.next

            cur.next, head.next, head = head, cur.next, head.next

            if head and cur.val > head.val:
                cur = parent

        return parent.next
```

### [ê°€ì¥ í° ìˆ˜](https://leetcode.com/problems/largest-number/)

í•­ëª©ë“¤ì„ ì¡°í•©í•˜ì—¬ ë§Œë“¤ ìˆ˜ ìˆëŠ” ê°€ì¥ í° ìˆ˜ë¥¼ ì¶œë ¥í•˜ë¼.

```
Input: nums = [10,2]
Output: "210"
---
Input: nums = [3,30,34,5,9]
Output: "9534330"
```

- í’€ì´: ì‚½ì… ì •ë ¬

```python
class Solution:
		# ìŠ¤ì™‘ì„ í•´ì¤„ í•¨ìˆ˜ë¥¼ ì •ì˜
    @staticmethod
    def to_swap(n1: int, n2: int) -> bool:
        return str(n1) + str(n2) < str(n2) + str(n1)

    def largestNumber(self, nums: List[int]) -> str:
        i = 1

        while i < len(nums):
            j = i
            while j > 0 and self.to_swap(nums[j - 1], nums[j]):
                nums[j], nums[j - 1] = nums[j - 1], nums[j]
                j -= 1
            i += 1

        return str(int(''.join(map(str, nums))))
```

- í’€ì´: ê°€ì¥ ë¹ ë¥¸ ì²˜ë¦¬ ì†ë„

```python
class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        for i, n in enumerate(nums):
            nums[i] = str(n)
        
        def compare(nums1, nums2):
            if nums1 + nums2 > nums2 + nums1:
                return -1
            else:
                return 0        
        nums = sorted(nums,key= cmp_to_key(compare))
        str_list = ''.join(nums)
        num_str = str_list.lstrip("0")
        if(not num_str):
            num_str = "0"
        return num_str
```

**ğŸ¤” `cmp_to_key`ë€?**

`functool.cmp_to_key()`ë¡œì„œ, sorted í•¨ìˆ˜ì˜ key ë§¤ê°œë³€ìˆ˜ì— í•¨ìˆ˜ë¥¼ ì „ë‹¬í•  ë•Œ ì‚¬ìš©í•œë‹¤. ì¦‰, ì§ì ‘ ì •ë ¬í•˜ëŠ” í•¨ìˆ˜ë¥¼ ë§Œë“¤ì–´ ê·¸ê²ƒì„ keyì— ì ìš©ì‹œí‚¤ëŠ” ë°©ì‹ì´ë¼ ë³¼ ìˆ˜ ìˆë‹¤.

### [ìœ íš¨í•œ ì—ë„ˆê·¸ë¨](https://leetcode.com/problems/valid-anagram/)

tê°€ sì˜ ì• ë„ˆê·¸ë¨ì¸ì§€ íŒë³„í•˜ë¼.

```
Input: s = "anagram", t = "nagaram"
Output: true
---
Input: s = "rat", t = "car"
Output: false
```

- í’€ì´: ì •ë ¬ì„ ì´ìš©í•œ ë¹„êµ

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        return sorted(s) == sorted(t)
```

### [ìƒ‰ ì •ë ¬](https://leetcode.com/problems/sort-colors)

ë¹¨ê°„ìƒ‰ì„ 0, í°ìƒ‰ì„ 1, íŒŒë€ìƒ‰ì„ 2ë¼í•  ë•Œ ìˆœì„œëŒ€ë¡œ ì¸ì ‘í•˜ëŠ” ì œìë¦¬ ì •ë ¬ì„ ìˆ˜í–‰í•˜ë¼.

```
Input: nums = [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
---
Input: nums = [2,0,1]
Output: [0,1,2]
```

- í’€ì´: `.sort()` í•¨ìˆ˜ ì‚¬ìš©

```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        return nums.sort()
```

- í’€ì´: ë„¤ëœë€ë“œ êµ­ê¸° ë¬¸ì œë¥¼ ì‘ìš©í•œ í’€ì´
    
    ì´ í’€ì´ëŠ” ì–‘ìª½ì— í¬ì¸í„°ë¥¼ ë‘ê³  ê°€ìš´ë° ê°’ì„ ê¸°ì¤€ìœ¼ë¡œ ìŠ¤ì™‘í•˜ëŠ” í˜•íƒœë¡œ êµ¬í˜„ë˜ëŠ” ì½”ë“œë‹¤.
    

```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        red, white, blue = 0, 0, len(nums)

        while white < blue:
            if nums[white] < 1:
                nums[red], nums[white] = nums[white], nums[red]
                white += 1
                red += 1
            elif nums[white] > 1:
                blue -= 1
                nums[white], nums[blue] = nums[blue], nums[white]
            else:
                white += 1
```

### ì›ì ì—ì„œ kë²ˆì§¸ë¡œ ê°€ê¹Œìš´ ì 

ì›ì ì—ì„œ kë²ˆì§¸ë¡œ ê°€ê¹Œìš´ ì  ëª©ë¡ì„ ìˆœì„œëŒ€ë¡œ ì¶œë ¥í•˜ë¼.

```
Input: points = [[1,3],[-2,2]], k = 1
Output: [[-2,2]]
Explanation:
The distance between (1, 3) and the origin is sqrt(10).
The distance between (-2, 2) and the origin is sqrt(8).
Since sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.
We only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].
---
Input: points = [[3,3],[5,-1],[-2,4]], k = 2
Output: [[3,3],[-2,4]]
Explanation: The answer [[-2,4],[3,3]] would also be accepted.
```

- ì‹œë„í•œ í’€ì´

```python
class Solution:
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        points_length = {}

        for point in points:
            length = (point[0] ** 2 + point[1] ** 2) ** (1/2)
            points_length[length] = point

        points_length = sorted(points_length.items())
        answer = []

        for i, j in points_length:
            answer.append(j)        
        
        return answer[:k]
```

ëŒ€ë¶€ë¶„ì˜ caseì—ì„œëŠ” í†µê³¼ê°€ ë˜ì—ˆì§€ë§Œ **points = [[1,0], [0,1]], k = 2**ì™€ ê°™ì´ ê±°ë¦¬ê°€ ê°™ì€ ê²½ìš°, ë”•ì…”ë„ˆë¦¬ ì¤‘ë³µìœ¼ë¡œ ì¸í•´ì„œ ì¢Œí‘œê°’ì´ ì œëŒ€ë¡œ ì…ë ¥ë˜ì§€ ì•Šì•„ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ì˜€ë‹¤.

- í’€ì´: heapqë¥¼ ì´ìš©í•œ í’€ì´

```python
class Solution:
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        heap = []

        for (x, y) in points:
            # ê²°êµ­ ë£¨íŠ¸ëŠ” ê±°ë¦¬ë¥¼ ì •í™•í•˜ê²Œ í‘œí˜„í•˜ê¸° ìœ„í•œ ìˆ˜ë‹¨ì¼ ë¿, ìˆœì„œë¥¼ ë§ì¶”ëŠ”ë°ëŠ” í•„ìš”ê°€ ì—†ê¸°ì— ê³„ì‚° ê³¼ì •ì„ ìƒëµ
            dist = x ** 2 + y ** 2
            heapq.heappush(heap, (dist, x, y))

        result = []

        for _ in range(k):
            # heapqì˜ ëª¨ë“ˆì€ ìµœì†Œ í™ìœ¼ë¡œ ë˜ì–´ìˆê¸°ì— distê°€ ê°€ì¥ ê°€ê¹Œìš´ ìˆœìœ¼ë¡œ popì´ ëœë‹¤.
            (dist, x, y) = heapq.heappop(heap)
            result.append((x, y))

        return result
```

- í’€ì´: ê°€ì¥ ë¹ ë¥¸ ì‘ë‹µì‹œê°„

```python
class Solution:
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        return sorted(points, key = lambda x : x[0]*x[0] + x[1]*x[1])[:k]
```